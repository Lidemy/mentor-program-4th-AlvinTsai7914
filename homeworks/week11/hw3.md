## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

雜湊與加密的差別在於雜湊不可從結果逆推，加密可以。

**加密：**將原本的資料透過一定的加密演算法（密鑰）轉換成加密後的資料，例如：

1. 加密演算法為  `[ i * 3 - i ]`

2. 原資料為 `123`

3. 加密後就是 ` [1*3-1][2*3-2][3*3-3] == 246 `

但只要密鑰被破解或竊取，那所有加密過後的資料都可以被倒推回去，有一定的風險性。

**雜湊：**將原本資料演算成固定長度的加密資料，不同長度的輸入都會有相同長度的加密輸出，低機率的出現兩組不同的資料輸出解果相同，並且在最後輸出中加入一組亂數（加鹽），由於碰撞的可能性還有加鹽的動作，讓每組輸出難以被逆推。

因為相同的輸入經過雜湊出來的結果一定相同，所以資料庫不需要知道使用者的密碼是什麼，只需要存取雜湊出來的結果，當使用者要驗證密碼時，運用相同的雜湊方法輸出，並檢查是否與資料庫存取的雜湊結果符合，這樣就不會出現資料庫被盜而所有使用者的密碼外洩的問題。

## `include`、`require`、`include_once`、`require_once` 的差別

require 和 include 都是運行 php 程式碼。

**require **若無法讀取引入的程式，整份文件都會停止運行，若有引入，則會將引入的程式做為整份文件的一部分。

**include **無法導入時會出現警告但還是會將整份文件運行完畢，並且 include 只要被讀取到就會運行一次，例如放入迴圈時 include 就會被多次的執行。

而 **include_once** 和 **require_once **則是增加了檢查之前有沒有被引入過，如果有的話則不會再次引入。

## 請說明 SQL Injection 的攻擊原理以及防範方法

SQL Injection 是利用 SQL 語法的規則，在使用者輸入的地方利用惡意的語法， 讓原本用來存取或是提取資料的 SQL query 變成另一個意思。

例如：

``` JS
sql = select * form users where username = "$username"(使用者輸入的帳號) and password = "$password"(使用者輸入的密碼)
```

這時在若攻擊者在 $username 寫上 

``` JS
 "or 1=1 /*
```

這時整個 SQL query 就會變成

```JS
sql = select * form users where username = " "or 1=1 (後面的都被/*註解掉了)/*" and password = ""
```

這時候雖然前面沒有帳號，但 or 後面的 1=1 成立，server 就會將 users 裡所有的資料都提取出來，用類似的手法甚至可以竄改刪除或是盜用資料。

而防範的方法就是使用 Prepared Statement ，Prepared Statement 會將使用者輸入的資料和 SQL query 句子分別開來，這樣就算填入惡意語法例如上面的  "or `1=1 /*`，程式還是會判斷這整個為一個字串而非 SQL query 的一部分。

##  請說明 XSS 的攻擊原理以及防範方法

**Cross-Site Scripting 跨網站指令碼**，攻擊者透過在網頁中插入 `<script>`標籤來執行特定的 JS 程式，例如在網站的留言板中上寫下` <script> alert('123') </script>`，當網站讀取跑到段留言時，就會以會有段`alert('123')`要執行並彈跳出 alert。以這樣的方法，攻擊者就能做到跳轉到釣魚網站或是執行某些惡意指令。

所以在網站當中如果有使用者能夠控制並「顯示」在網頁的地方（留言板、使用者暱稱等），PHP 內建的 htmlspecialchars()或 JS 自己寫 escape() 函式，讓網頁讀取時跳脫特定的地方。

## 請說明 CSRF 的攻擊原理以及防範方法

**Cross Site Request Forgery 跨站請求偽造** ，攻擊者用一些欺騙掩飾的手法，攻擊用戶瀏覽器已經驗證過的網站，由於 server 從身分驗證只能檢查是否為同一個用戶和瀏覽器，但不能確認 request 是否為使用者自願發出，所以攻擊者可以用圖片或是按鈕帶上攻擊的代碼，當使用者進入網站或是點下按鈕，就會在使用者不知情的情況下發出請求給已經驗證過的網站，以達到欺騙 server 的效果。

由於 CSRF 是透過使用者不知情的清況下從非主網站傳出 request，所以我們可以透過 **Double Submit Cookie**， server 端在使用者 cookie 和 form 裡儲存 csrftoken，當使用者送出 request 時，伺服器驗證兩邊的 csrftoken 是否一致來達到確認這個 request 是從主網站送出，或是使用瀏覽器的 **SameSite** 功能，限制 token 只能被同 domain 使用，來達到防範 CSRF 的效果。